---
title: php面试题整理-mysql
date: 2017-10-09 11:30:20
tags:
	- php面试
	- mysql
---
## 数据类型 ##

##### 整型 #####

INT(0) 0 代表宽度，对大多数应用是没有意义的，它不会限制值的范围，只会影响显示字符的个数。为zerofill服务。

##### 字符型 #####

- VARCHAR 

	+ 用于存储可变长度字符串，比定长类型更节省空间；
	
	+ 使用1或者2个额外字节记录字符串的长度，列长度小于255字节，使用1个字节表示，否则2个；
	
	+ 如果存储内容超出指定长度，会被截断。
<!-- more -->		
- CHAR 

	+ 定长，根据定义的字符串长度分配足够的空间；

	+ 会根据需要采用空格进行填充方便进行比较，适合存储很短的字符串，或者所有值都接近同一个长度；

	+ 如果存储内容超出指定长度，会被截断。

对于经常变更的数据，CHAR比VARCHAR更好，CHAR不容易产生碎片；

对于非常短的列，CHAR比VARCHAR在存储空间上更有效率

##### 日期和时间类型 #####
		
- 尽量使用TIMESTAMP，比DATETIME空间效率高；

- 用整数保存时间戳的格式通常不方便处理；
		
- 如果需要储存微秒，可以使用bigint存储。

## 存储引擎 ##

##### innoDB #####

- 默认事务型引擎，数据存储在共享表空间，可以通过配置分开；

- 对主机间查询的性能高于其他类型的存储引擎；

- 从磁盘读取数据时自动在内存构建hash索引，插入数据时自动构建插入缓冲区；

- 通过一些机制和工具支持真正的热备份；

- 支持崩溃后的安全恢复；

- 支持行级锁；

- 支持外键。

##### MyISAM #####

- 5.1之前，默认存储引擎；
	
- 拥有全文索引、压缩、空间函数；
	
- 不支持事务和行级锁，不支持崩溃后的安全恢复；
	
- 表从存储在两个文件，MYD和MYI；

##### 其他表引擎 #####

archive blackhole csv memory

## 锁机制 ##

共享锁/读锁：共享，不堵塞，多个用户可以同时读一个资源，互不干扰。

排他锁/写锁：排他，一个写锁会阻塞其他的写锁和读锁，只允许一个人进行写入，防止其他用户读取正在写入的资源。

##### 锁粒度 #####

- 表锁：系统性能开销最小，会锁定整张表，MyISAM使用表锁。
	
- 行锁，最大程度地支持并发处理，但带来最大的锁开销，InnoDB使用。

## 索引 ##

##### 类型 #####

组合索引 外键索引 全文索引

- 一个表只能有一个主键索引，可以有多个唯一索引；

- 主键索引一定是唯一索引，唯一索引不是主键索引；

- 主键可以与外检构成参照完整性约束，防止数据不一致。

##### 创建原则 #####

- 最适合索引的列是出现在where子句中的列，或者连接子句中的列而不是出现在select关键字后的列；

- 索引列的基数越大越好；

- 对字符串进行索引，应该制定一个前缀长度，可以节省大量的索引空间；

- 根据情况创建复合索引，可以提高查询效率；

- 避免创建过多索引，索引会额外占用磁盘空间，降低写操作效率；

- 主键尽可能选择较短的数据类型，可以有效减少索引的磁盘占用空间，提高查询效率。

##### 对性能的影响 #####
 
- 大大减少服务器需要扫描的数据量；

- 帮助服务器避免排序和临时表；

- 将随机I/O变顺序I/O；

- 大大提高查询素的，降低写的速度，占用磁盘；

- 主键可以与外检构成参考完整性约束，防止数据不一致。

##### 注意事项 #####

- 复合索引遵循前缀原则;

- like查询，%不能在前，可以使用全文索引（其替代sphinx）;

- column is null 可以使用索引;

- 若mysql估计使用索引比全表扫描慢，会放弃使用索引;

- 如果or前的条件中的列有索引，后面没有，索引都不会被用到;

- 列类型是字符串，查询时一定要给值加引号，否则索引失效.

## 关联更新 ##

	UPDATE A,B SET A.c1 = B.c1, A.c2 = B.c2 WHERE A.id = B.id
	UPDATE A INNER JOIN B ON A.id = B.id SET A.c1 = B.c2 WHERE...

## 全连接 ##

	SELECT * FROM A LEFT JOIN B ON A.id = B.id UNION
	SELECT * FROM A RIGHT JOIN B ON A.id = B.id

## 优化 ##

先说明如何定位低效sql语句，然后根据sql语句可能低效的原因做排查，先从索引着手，如果索引没有问题，考虑以下几个方面，数据访问的问题，长难查询句的问题还是一些特定类型优化的问题，逐一回答。

### eg.  ###

简述项目中优化sql语句执行效率的方法，从哪些方面，sql语句性能如何分析？

##### 分析 sql 查询慢的方法######

- 记录慢查询日志，用pt-query-digest

- show profile
	

		set profiling = 1; 开启，服务器上执行的所有语句会检测消耗的时间，存到临时表中
		show profiles
		show profile for query 临时表ID

- show status：会返回一些计数器，`show global status`查看服务器级别的所有计数；有时根据这些计数，可以猜测出哪些操作代价较高或者消耗时间多。

- show processlist：观察是否有大量线程处于不正常的状态或特征

- explain / desc：分析单条sql语句	

##### 优化 #####

1、数据访问：
	
- 访问数据太多导致查询性能下降，eg. SELECT *... —— limit。

- 确定应用程序是否在检索大量超过需要的数据，可能太多行或列；确认mysql服务器是否在分析大量不必要的数据行

 + 多表关联：A.id|,B.name 

 + 缓存。

- 是否在扫描额外的记录：使用explain来进行分析，如果发现查询需要扫描大量的数据但只返回少数的行，可通过如下技巧优化：

 + 使用索引覆盖扫描，把所有有用的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果；

 + 改变数据库和表的结构，修改数据表的范式（冗余）；

 + 重写sql语句，让优化器可以以更优的方式执行查询。

2、优化长难的查询语句：

- 切分查询：将一次大的查询分为多个小的相同的查询。eg. 一次性删除1000万的数据要比一次删除1万，暂停一会的方案会更加损耗服务器开销。
 
- 分解关联语句：

 + 将一条关联语句分解成多条sql来执行让缓存的效率更高；
 
 + 执行单个查询可以减少锁竞争；
 
 + 在应用层做关联可以更容易对数据库进行拆分：分库分表。

3、优化特定类型的查询语句：

- count()

 + count(*) 中 * 会忽略所有的列，直接统计所有列数，因此不要使用count(列名)

 + myisam没有任何where条件中的count(*)分非常快

 + 可以使用explain查询近似值，用近似值来替代count(*)

 + 增加汇总表；

 + 使用缓存。

- 优化关联查询

 + 确定ON或者USING子句的列上有索引；
		
 + 确保 `GROUP BY` 和 `ORDER BY` 中只有一个表中的列，这样 MySQL **才可能使用索引**。

- 优化子查询：尽可能使用关联查询代替

- 优化group by和distinct

 + 索引是最有效的优化方法；

 + 关联查询中，使用标识列进行分组的效率会更高；
 
 + 如果不需要 `order by`，进行`group by`时使用`order by null`，mysql不会再进行文件排序；

 + with rollup 超级聚合，可以挪到程序中处理

- 优化limit分页：limit偏移量大的时候，查询效率低，可以记录上次查询的最大id，下次查询时直接根据该id来查询。

- 优化union：union all的效率高于union

## 分表分区 ##

##### 分区工作原理 #####

对用户而言，分区表是一个独立的逻辑表，但底层mysql将其分成了多个物理子表，这对用户是透明的，每个分区表都会使用一个独立的表文件。

创建表示使用partition by子句定义每个分区存放的数据，执行查询时，优化器会根据分区定义过滤那些没有我们需要数据分分区，只需要查询所需数据所在的分区即可。

##### 分区使用场景 #####

- 表非常大，无法全部存入内存，或者只在表的最后有热点数据，其他都是历史数据
			
- 分区表的数据更易维护，可以对独立的分区进行独立的操作

- 分区表的数据可以分布在不同的机器上，从而高效使用资源

##### 分区限制 #####
			
- 一个表只能使用1024个分区

- 5.1版本中，分区表表达式必须是整数，5.5可以使用列分区
			
- 分区字段中如果有主键和唯一索引列，那么主键列和唯一列都必须包含进来
			
- 无法使用外键索引

- 需要对现有表结构进行修改

- 所有分区表都必须使用相同的存储引擎

- 分区函数中可以使用的函数和表达式也会有一些限制

- 某些存储引擎不支持分区

- 对于myisam的分区表，不能使用load index into cache

- 对于myisam表，使用分区表时需要打开更多的文件描述符

##### 分库分表原理 #####

通过一些hash算法或者工具实现将一张数据表垂直或水平进行物理分割

##### 分库分表适用场景 #####

- 单表记录条数达到百万到千万级别时

- 解决表锁的文件

##### 分库分表缺点 #####

- 有些分表的策略基于应用层的逻辑算法，一旦逻辑算法改变，整个分表逻辑都会改变，拓展性差

- 对于应用层来说，逻辑算法无疑增加开发成本

## 复制 ##

##### 主从复制工作原理 #####

- 在主库上把数据更改记录到二进制日志

- 从库将主库的日志复制到自己的中继日志

- 从库读取日志中的事件，将其虫放到从库数据中

##### 解决的问题 #####

- 数据分布：随意停止或开始复制，并在不同的地理位置分布数据备份

- 负载均衡：降低单个服务器的压力

- 高可用和故障切换：帮助应用程序避免单点失败

- 升级测试：可以使用更高版本的mysql作为从库

##### eg. #####

设定网站的用户数量在千万级，但是活跃用户的数量只有1%，如果优化数据库提高访问速度？

- mysql分区，活跃用户区/不活跃用户表

- 水平分表

## 安全性 ##

- 预处理语句防sql注入：`delete from user where id = ? prepare`

- 尽量使用pdo

- 写入数据库的数据要进行特殊字符的转义

- 查询错误信息不要返回给用户，将错误记录到日志